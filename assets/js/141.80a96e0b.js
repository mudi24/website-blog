(window.webpackJsonp=window.webpackJsonp||[]).push([[141],{426:function(n,t,e){"use strict";e.r(t);var a=e(14),s=Object(a.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h3",{attrs:{id:"computed"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#computed"}},[n._v("#")]),n._v(" computed")]),n._v(" "),e("ul",[e("li",[e("p",[n._v("computed 默认只有 getter，需要的时候也可以提供 setter")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("    computed:{\n      displayName: {\n        get(){\n          const user = this.user\n          return user.nickname || user.phone || user.email\n        }\n        set(value){\n          this.user.nickname = value\n        }\n      }\n    }\n")])])])]),n._v(" "),e("li",[e("p",[n._v("计算属性的结果会缓存")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('    computed:{\n      displayUsers(){\n        const hash = {\n          male: \'男\',\n          female: \'女\'\n        }\n        const { users, gender } = this\n        if(gender === ""){\n          return users\n        } else if(typeof gender === "string"){\n          return users.filter(u => u.gender === hash[gender])\n        } else {\n          throw new Error("意料之外的值")\n        }\n      }\n    },\n')])])])])]),n._v(" "),e("h3",{attrs:{id:"watch"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#watch"}},[n._v("#")]),n._v(" watch")]),n._v(" "),e("ul",[e("li",[e("p",[n._v("watch 是异步的，可以在数据变化之后立即使用 Vue.nextTick(callback)/vm.$nextTick()。这样回调函数将在 DOM 更新完成后被调用。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('  new Vue({\n    data:{\n      n: 0,\n      history: [],\n      inUndoMode: false\n    },\n    watch: {\n      n(newValue, oldValue){\n        if(!this.inUndoMode){  // 判断是否为撤销模式\n          this.history.push({from: oldValue, to: newValue})\n        }\n      }\n    },\n    template: `\n      <div>\n        {{n}}\n        <hr />\n        <button @click="add1">+1</button>\n        <button @click="add2">+2</button>\n        <button @click="minus1">-1</button>\n        <button @click="minus2">+2</button>\n        <hr />\n        <button @click="undo">撤销</button>\n        <hr />\n      </div>\n    `,\n    methods:{\n      add1(){this.n += 1},\n      add2(){this.n += 2},\n      minus1(){this.n -= 1},\n      minus2(){this.n -= 2},\n      undo(){   // 撤销\n        const last = this.history.pop()\n        const old = last.from\n        this.inUndoMode = true\n        this.n = old\n        this.$nextTick(()=>{ // 等到watch异步操作执行完毕后再关闭撤销模式\n          this.inUndoMode = false\n        })\n      }\n    },\n  }).mounted("#app")\n')])])])]),n._v(" "),e("li",[e("p",[n._v("watch 默认只会监听数据的变化(数据第一次渲染不监听)")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("  watch:{\n    'user email':{\n      handler(){\n        const { user: {nickname, email, phone }} = this;\n        // user不可用了,只能用nickname,email,phone\n        this.displayName = nickname\n      },\n      immediate: true  // 加上这句会监听数据第一次渲染\n    }\n  }\n")])])])]),n._v(" "),e("li",[e("p",[n._v("简单类型变化对比值，复杂类型(对象)变化对比地址")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("  watch:{\n    obj:{\n      handler(){\n        console.log('obj变化了')\n      },\n      deep: true // 监听对象内部值的变化(监听数组不需要这么做)\n    }\n  }\n")])])])])]),n._v(" "),e("ul",[e("li",[n._v("watch 语法"),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("  watch:{\n    add1: function(value, oldValue){}\n    add2(){}\n    add3:[fn1, fn2] // 一次执行fn1, fn2\n    add4:'add' // methods中的add函数\n    add5:{handler:fn, deep:true, immediate:true}\n    'object.a': function(){} // 监听对象属性的变化\n  }\n  vm.$watch('n', function(){}, {immediate: true})\n")])])])]),n._v(" "),e("li",[n._v("vm.$watch 返回一个取消观察函数，用来停止触发回调"),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("let unwatch =vm.$watch('a', cd)\nunwatch() // 取消观察\n")])])])])]),n._v(" "),e("h3",{attrs:{id:"computed-和-watch-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#computed-和-watch-的区别"}},[n._v("#")]),n._v(" computed 和 watch 的区别")]),n._v(" "),e("ul",[e("li",[n._v("computed: 计算属性，watch: 监听")]),n._v(" "),e("li",[n._v("computed 调用时不需要加括号，会缓存结果，需要依赖其他数据来得到结果时使用 computed")]),n._v(" "),e("li",[n._v("watch 有 immediate 和 deep 选项，是异步的，需要在数据变化时进行操作使用 watch")])])])}),[],!1,null,null,null);t.default=s.exports}}]);