(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{328:function(e,t,s){"use strict";s.r(t);var n=s(14),a=Object(n.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h4",{attrs:{id:"usestate"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#usestate"}},[e._v("#")]),e._v(" useState")]),e._v(" "),s("ul",[s("li",[e._v("使用方法：")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("const [n,setN] = React.useState(0)\nconst [user,setUser] = React.useState({name:'F})\nconst [state,setState] = React.useState(()=>({name:'F}))\n    // 可以接收函数，该函数返回初始state，且只执行一次\n")])])]),s("ul",[s("li",[e._v("注意：\n"),s("ul",[s("li",[e._v("不可以局部更新（需要自己合并属性，useReducer 也需要自己合并）")]),e._v(" "),s("li",[e._v("不能写到 if 中")]),e._v(" "),s("li",[e._v("对象的地址不变，内部改变，React 认为没有变化（要使用 setUser({})）")]),e._v(" "),s("li",[e._v("setState(i => i + 1)，需要对 state 进行多次 setState 的操作时，使用函数")])])])]),e._v(" "),s("h4",{attrs:{id:"usereducer"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#usereducer"}},[e._v("#")]),e._v(" useReducer")]),e._v(" "),s("ul",[s("li",[s("p",[e._v("复杂版的 useState(用来践行 Flux/Redux 的思想)")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('    const initial = { n: 0 };\n\n    const reducer = (state, action) => {\n      if (action.type === "add") {\n        return { n: state.n + action.number };\n      } else if (action.type === "multi") {\n        return { n: state.n * 2 };\n      } else {\n        throw new Error("unknown type");\n      }\n    };\n\n    function App() {\n      const [state, dispatch] = useReducer(reducer, initial);\n      const { n } = state;\n      const onClick = () => {\n        dispatch({ type: "add", number: 1 });\n      };\n      const onClick2 = () => {\n        dispatch({ type: "add", number: 2 });\n      };\n      return (\n        <div className="App">\n          <h1>n: {n}</h1>\n          <button onClick={onClick}>+1</button>\n          <button onClick={onClick2}>+2</button>\n        </div>\n      );\n    }\n')])])])])]),e._v(" "),s("h4",{attrs:{id:"使用-usereducer-和-usecontext-代替-redux"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#使用-usereducer-和-usecontext-代替-redux"}},[e._v("#")]),e._v(" 使用 useReducer 和 useContext 代替 redux")]),e._v(" "),s("ul",[s("li",[e._v("步骤：\n"),s("ul",[s("li",[e._v("将数据集中到一个 store 对象")]),e._v(" "),s("li",[e._v("将所有操作都集中到 reducer")]),e._v(" "),s("li",[e._v("创建一个 Context")]),e._v(" "),s("li",[e._v("创建对数据的读写 API")]),e._v(" "),s("li",[e._v("将 API 放入 Context")]),e._v(" "),s("li",[e._v("用 Content.Provider 将 Context 提供给所有组件")]),e._v(" "),s("li",[e._v("各个组件用 useContext 获取读写 API")])])])]),e._v(" "),s("ul",[s("li",[e._v("实例：https://codesandbox.io/s/sparkling-sound-pj4yd")])]),e._v(" "),s("h4",{attrs:{id:"usecontext"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#usecontext"}},[e._v("#")]),e._v(" useContext")]),e._v(" "),s("ul",[s("li",[e._v("注意：使用 useContext 时，在后代组件使用 set 操作改变了值之后，后代组件会通知祖先，祖先进行对比找到要修改的后代组件，然后对修改的组件进行更新")])]),e._v(" "),s("h4",{attrs:{id:"useeffect-副作用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#useeffect-副作用"}},[e._v("#")]),e._v(" useEffect 副作用")]),e._v(" "),s("ul",[s("li",[e._v("对环境的改变即为副作用，可以理解为 afterRender")]),e._v(" "),s("li",[e._v("作为 componentDidMount 使用，[]作为第二个参数")]),e._v(" "),s("li",[e._v("作为 componentDidUpdate 使用，[]内写要监听的 state")]),e._v(" "),s("li",[e._v("作为 componentWillUnmount 使用，使用 return 一个函数")]),e._v(" "),s("li",[e._v("如果同时存在多个 useEffect，会按出现顺序执行")])]),e._v(" "),s("h4",{attrs:{id:"uselayouteffect-布局副作用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#uselayouteffect-布局副作用"}},[e._v("#")]),e._v(" useLayoutEffect 布局副作用")]),e._v(" "),s("ul",[s("li",[e._v("useEffect 在浏览器渲染完成后执行")]),e._v(" "),s("li",[e._v("useLayoutEffect 在浏览器渲染前执行")]),e._v(" "),s("li",[e._v("如果 useLayoutEffect 中的操作不影响布局，使用 useEffect 代替它")])]),e._v(" "),s("h4",{attrs:{id:"usememo"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#usememo"}},[e._v("#")]),e._v(" useMemo")]),e._v(" "),s("ul",[s("li",[s("p",[e._v("memo")]),e._v(" "),s("ul",[s("li",[e._v("React.memo()，使用 memo 可以让组件只在自身的 props 变化后执行，避免多余的 render，节省性能")]),e._v(" "),s("li",[e._v("如果祖先组件为该后代组件添加了监听函数，因为祖先组件更新后会重新执行，就会得到新的监听函数，地址变化导致后代组件 render")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('    const Child = React.memo(props => {\n      console.log("child 执行了");\n      console.log("假设这里有大量代码");\n      return <div>child: {props.data}</div>;\n    });\n')])])])]),e._v(" "),s("li",[s("p",[e._v("useMemo --\x3e (Vue2 computed)???")]),e._v(" "),s("ul",[s("li",[e._v("第一个参数是()=>value")]),e._v(" "),s("li",[e._v("第二个参数是依赖[m,n]")]),e._v(" "),s("li",[e._v("只有当依赖变化时，才会计算新的 value")]),e._v(" "),s("li",[e._v("如果依赖不变就重用之前的 value")])]),e._v(" "),s("ul",[s("li",[e._v("那么如果 value 是个函数，就要写成\n"),s("code",[e._v("useMemo(()=>(x)=>console.log(x),[m])")])])])])]),e._v(" "),s("ul",[s("li",[e._v("useCallback 语法糖\n"),s("ul",[s("li",[e._v("可以使用"),s("code",[e._v("useCallback(x => console.log(x),[m])")]),e._v("代替 "),s("code",[e._v("useMemo(()=>(x)=>console.log(x), [m])")])])])])]),e._v(" "),s("h4",{attrs:{id:"useref"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#useref"}},[e._v("#")]),e._v(" useRef")]),e._v(" "),s("ul",[s("li",[e._v("需要一个值，在组件不断 render 时保持不变")]),e._v(" "),s("li",[e._v("初始化：const count = useRef(0)")]),e._v(" "),s("li",[e._v("读取：count.current")]),e._v(" "),s("li",[e._v("为什么需要 current？ 保证两次 useRef 是同一个值")])]),e._v(" "),s("h4",{attrs:{id:"vue3-ref"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue3-ref"}},[e._v("#")]),e._v(" Vue3 ref")]),e._v(" "),s("ul",[s("li",[e._v("初始化： const count = ref(0)")]),e._v(" "),s("li",[e._v("读取：count.value")]),e._v(" "),s("li",[e._v("不同点：count.value 变化时，会自动 render 更新 UI")])]),e._v(" "),s("h4",{attrs:{id:"forwardref"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#forwardref"}},[e._v("#")]),e._v(" forwardRef")]),e._v(" "),s("ul",[s("li",[e._v("props 不包含 ref 属性，无法传递 ref 属性")])]),e._v(" "),s("ul",[s("li",[s("p",[e._v("函数组件无法直接接收传入的 ref 属性")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('    function App(){\n      const buttonRef = useRef(null)\n      return (\n        <div className="App">\n          <Button ref={buttonRef}>按钮</Button>\n        </div>\n      )\n    }\n    const Button = React.forwardRef((props, ref)=>{\n      return <button ref={ref} {...props}/>\n    })\n')])])])])]),e._v(" "),s("h4",{attrs:{id:"useimperativehandle"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#useimperativehandle"}},[e._v("#")]),e._v(" useImperativeHandle")]),e._v(" "),s("ul",[s("li",[s("p",[e._v("可以理解为 setRef，自定义 ref 的属性")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("    const Button2 = React.forwardRef((props, ref) => {\n      const realButton = createRef(null);\n      const setRef = useImperativeHandle;\n      setRef(ref, () => {\n        return {\n          x: () => {\n            realButton.current.remove();\n          },\n          realButton: realButton\n        };\n      });\n      return <button ref={realButton} {...props} />;\n    });\n")])])])])]),e._v(" "),s("h4",{attrs:{id:"自定义-hook"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#自定义-hook"}},[e._v("#")]),e._v(" 自定义 Hook")]),e._v(" "),s("ul",[s("li",[e._v("自定义 Hook 里使用 Context")]),e._v(" "),s("li",[e._v("可以代替 redux"),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('    const useList = () => {\n      const [list, setList] = useState(null);\n      useEffect(() => {\n        ajax("/list").then(list => {\n          setList(list);\n        });\n      }, []); // [] 确保只在第一次运行\n      return {\n        list: list,\n        addItem: name => {\n          setList([...list, { id: Math.random(), name: name }]);\n        },\n        deleteIndex: index => {\n          setList(list.slice(0, index).concat(list.slice(index + 1)));\n        }\n      };\n    };\n    export default useList;\n')])])])])]),e._v(" "),s("h4",{attrs:{id:"stale-closure-过时闭包"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#stale-closure-过时闭包"}},[e._v("#")]),e._v(" Stale Closure 过时闭包")]),e._v(" "),s("ul",[s("li",[e._v("函数引用的变量是之前的变量")])])])}),[],!1,null,null,null);t.default=a.exports}}]);