(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{301:function(t,a,s){"use strict";s.r(a);var r=s(14),e=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"性能优化建议"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#性能优化建议"}},[t._v("#")]),t._v(" 性能优化建议")]),t._v(" "),s("h3",{attrs:{id:"_1-减少-http-请求-把多个小文件合并为一个大文件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-减少-http-请求-把多个小文件合并为一个大文件"}},[t._v("#")]),t._v(" 1. 减少 HTTP 请求，把多个小文件合并为一个大文件")]),t._v(" "),s("h3",{attrs:{id:"_2-使用-http2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-使用-http2"}},[t._v("#")]),t._v(" 2. 使用 HTTP2")]),t._v(" "),s("ul",[s("li",[t._v("解析速度快\n服务器解析 HTTP1.1 的请求时，必须不断地读入字节，直到遇到分隔符 CRLF 为止。而解析 HTTP2 的请求就不用这么麻烦，因为 HTTP2 是基于帧的协议，每个帧都有表示帧长度的字段。")]),t._v(" "),s("li",[t._v("多路复用\nHTTP1.1 如果要同时发起多个请求，就得建立多个 TCP 连接，因为一个 TCP 连接同时只能处理一个 HTTP1.1 的请求。\n在 HTTP2 上，多个请求可以共用一个 TCP 连接，这称为多路复用。同一个请求和响应用一个流来表示，并有唯一的流 ID 来标识。\n多个请求和响应在 TCP 连接中可以乱序发送，到达目的地后再通过流 ID 重新组建。")]),t._v(" "),s("li",[t._v("首部压缩\nHTTP/2 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送。")]),t._v(" "),s("li",[t._v("优先级\nHTTP2 可以对比较紧急的请求设置一个较高的优先级，服务器在收到这样的请求后，可以优先处理。")]),t._v(" "),s("li",[t._v("流量控制\n由于一个 TCP 连接流量带宽（根据客户端到服务器的网络带宽而定）是固定的，当有多个请求并发时，一个请求占的流量多，另一个请求占的流量就会少。流量控制可以对不同的流的流量进行精确控制。")]),t._v(" "),s("li",[t._v("服务器推送\nHTTP2 新增的一个强大的新功能，就是服务器可以对一个客户端请求发送多个响应。换句话说，除了对最初请求的响应外，服务器还可以额外向客户端推送资源，而无需客户端明确地请求。\n例如当浏览器请求一个网站时，除了返回 HTML 页面外，服务器还可以根据 HTML 页面中的资源的 URL，来提前推送资源。")])]),t._v(" "),s("h3",{attrs:{id:"_3-使用服务端渲染"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-使用服务端渲染"}},[t._v("#")]),t._v(" 3. 使用服务端渲染")]),t._v(" "),s("p",[t._v("客户端渲染: 获取 HTML 文件，根据需要下载 JavaScript 文件，运行文件，生成 DOM，再渲染。")]),t._v(" "),s("p",[t._v("服务端渲染：服务端返回 HTML 文件，客户端只需解析 HTML。")]),t._v(" "),s("ul",[s("li",[t._v("优点：首屏渲染快，SEO 好。")]),t._v(" "),s("li",[t._v("缺点：配置麻烦，增加了服务器的计算压力。")])]),t._v(" "),s("h3",{attrs:{id:"_4-静态资源使用-cdn"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-静态资源使用-cdn"}},[t._v("#")]),t._v(" 4. 静态资源使用 CDN")]),t._v(" "),s("p",[t._v("内容分发网络（CDN）是一组分布在多个不同地理位置的 Web 服务器。我们都知道，当服务器离用户越远时，延迟越高。CDN 就是为了解决这一问题，在多个位置部署服务器，让用户离服务器更近，从而缩短请求时间。")]),t._v(" "),s("h3",{attrs:{id:"_5-将-css-放在文件头部-javascript-文件放在底部"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-将-css-放在文件头部-javascript-文件放在底部"}},[t._v("#")]),t._v(" 5.将 CSS 放在文件头部，JavaScript 文件放在底部")]),t._v(" "),s("ul",[s("li",[t._v("CSS 执行会阻塞渲染，阻止 JS 执行")]),t._v(" "),s("li",[t._v("JS 加载和执行会阻塞 HTML 解析，阻止 CSSOM 构建")])]),t._v(" "),s("h3",{attrs:{id:"_6-使用字体图标iconfont代替图片图标"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-使用字体图标iconfont代替图片图标"}},[t._v("#")]),t._v(" 6.使用字体图标iconfont代替图片图标")]),t._v(" "),s("p",[t._v("字体图标就是将图标制作成一个字体，使用时就跟字体一样，可以设置属性，例如 font-size、color 等等，非常方便。并且字体图标是矢量图，不会失真。还有一个优点是生成的文件特别小。")]),t._v(" "),s("h3",{attrs:{id:"_7-善用缓存-不重复加载相同的资源"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-善用缓存-不重复加载相同的资源"}},[t._v("#")]),t._v(" 7.善用缓存，不重复加载相同的资源")]),t._v(" "),s("h3",{attrs:{id:"_8-压缩文件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-压缩文件"}},[t._v("#")]),t._v(" 8.压缩文件")]),t._v(" "),s("h3",{attrs:{id:"_9-图片优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-图片优化"}},[t._v("#")]),t._v(" 9.图片优化")]),t._v(" "),s("ol",[s("li",[t._v("图片延迟加载（懒加载）")]),t._v(" "),s("li",[t._v("响应式图片（根据屏幕大小加载合适的图片）")]),t._v(" "),s("li",[t._v("调整图片大小（加载缩略图，鼠标悬停加载大图）")]),t._v(" "),s("li",[t._v("降低图片质量和体积（image-webpack-loader 压缩）")]),t._v(" "),s("li",[t._v("尽可能利用 CSS3 效果代替图片")]),t._v(" "),s("li",[t._v("使用 webp 格式的图片")])]),t._v(" "),s("blockquote",[s("p",[t._v("WebP 的优势体现在它具有更优的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量；同时具备了无损和有损的压缩模式、Alpha 透明以及动画的特性，在 JPEG 和 PNG 上的转化效果都相当优秀、稳定和统一。")])]),t._v(" "),s("h3",{attrs:{id:"_10-通过-webpack-按需加载代码-提取第三库代码-减少-es6-转为-es5-的冗余代码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_10-通过-webpack-按需加载代码-提取第三库代码-减少-es6-转为-es5-的冗余代码"}},[t._v("#")]),t._v(" 10.通过 webpack 按需加载代码，提取第三库代码，减少 ES6 转为 ES5 的冗余代码")]),t._v(" "),s("blockquote",[s("p",[t._v("懒加载或者按需加载，是一种很好的优化网页或应用的方式。这种方式实际上是先把你的代码在一些逻辑断点处分离开，然后在一些代码块中完成某些操作后，立即引用或即将引用另外一些新的代码块。这样加快了应用的初始加载速度，减轻了它的总体体积，因为某些代码块可能永远不会被加载。")])]),t._v(" "),s("h4",{attrs:{id:"根据文件内容生成文件名-结合-import-动态引入组件实现按需加载"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#根据文件内容生成文件名-结合-import-动态引入组件实现按需加载"}},[t._v("#")]),t._v(" 根据文件内容生成文件名，结合 import 动态引入组件实现按需加载")]),t._v(" "),s("p",[t._v("通过配置 output 的 filename 属性可以实现这个需求。filename 属性的值选项中有一个 [contenthash]，它将根据文件内容创建出唯一 hash。当文件内容发生变化时，[contenthash] 也会发生变化。")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("output")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("filename")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'[name].[contenthash].js'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("chunkFilename")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'[name].[contenthash].js'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("path")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" path"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("resolve")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("__dirname"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'../dist'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n")])])]),s("h3",{attrs:{id:"_11-减少重绘重排"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_11-减少重绘重排"}},[t._v("#")]),t._v(" 11.减少重绘重排")]),t._v(" "),s("h3",{attrs:{id:"_12-使用事件委托"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_12-使用事件委托"}},[t._v("#")]),t._v(" 12.使用事件委托")]),t._v(" "),s("h3",{attrs:{id:"_13-表驱动编程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_13-表驱动编程"}},[t._v("#")]),t._v(" 13.表驱动编程")]),t._v(" "),s("h3",{attrs:{id:"_14-使用-web-workers"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_14-使用-web-workers"}},[t._v("#")]),t._v(" 14.使用 Web Workers")]),t._v(" "),s("p",[t._v("Web Worker 使用其他工作线程从而独立于主线程之外，它可以执行任务而不干扰用户界面。一个 worker 可以将消息发送到创建它的 JavaScript 代码, 通过将消息发送到该代码指定的事件处理程序（反之亦然）。\n不过在worker内，不能直接操作DOM节点，也不能使用window对象的默认方法和属性。然而你可以使用大量window对象之下的东西，包括WebSockets，IndexedDB以及FireFox OS专用的Data Store API等数据存储机制。")]),t._v(" "),s("h3",{attrs:{id:"_15-使用-transform-和-opacity-属性更改来实现动画"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_15-使用-transform-和-opacity-属性更改来实现动画"}},[t._v("#")]),t._v(" 15.使用 transform 和 opacity 属性更改来实现动画")]),t._v(" "),s("h3",{attrs:{id:"_16-合理使用规则-避免过度优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_16-合理使用规则-避免过度优化"}},[t._v("#")]),t._v(" 16.合理使用规则，避免过度优化")]),t._v(" "),s("p",[t._v("在 window.onload 事件里执行 new Date() - performance.timing.navigationStart 即可获取首屏时间。")])])}),[],!1,null,null,null);a.default=e.exports}}]);