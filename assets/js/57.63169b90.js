(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{334:function(t,e,n){"use strict";n.r(e);var a=n(14),s=Object(a.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h4",{attrs:{id:"今天我们来探究一下-react-hooks-的原理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#今天我们来探究一下-react-hooks-的原理"}},[t._v("#")]),t._v(" 今天我们来探究一下 React Hooks 的原理")]),t._v(" "),n("h5",{attrs:{id:"usestate"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#usestate"}},[t._v("#")]),t._v(" useState")]),t._v(" "),n("ul",[n("li",[n("p",[t._v("先来尝试实现单个数据的 useState")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('    let _state;\n    function myUseState(initialValue) {\n        _state = _state || initialValue;\n        function setState(newState) {\n          _state = newState;\n          render();\n        }\n        return [_state, setState];\n    }\n    const render = () => ReactDOM.render(<App />, rootElement);\n\n    function App() {\n        const [n, setN] = myUseState(0);\n        return (\n          <div className="App">\n            <p>{n}</p>\n            <p>\n              <button onClick={() => setN(n + 1)}>+1</button>\n            </p>\n          </div>\n        );\n    }\n    ReactDOM.render(<App />, rootElement);\n')])])])])]),t._v(" "),n("ul",[n("li",[n("p",[t._v("那么，如果要对两个或多个数据进行 useState 呢？")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('    let _state = [];\n    let index = 0;\n    const myUseState = initialValue => {\n        let currentIndex = index;\n        _state[currentIndex] =\n          _state[currentIndex] === undefined ? initialValue : _state[currentIndex];\n        const setState = newValue => {\n          _state[currentIndex] = newValue;\n          myRender();\n        };\n        index += 1;\n        return [_state[currentIndex], setState];\n    };\n    const myRender = () => {\n      index = 0\n      ReactDOM.render(<App />, rootElement);\n    };\n\n    function App() {\n        const [n, setN] = myUseState(0);\n        const [m, setM] = myUseState(0);\n        return (\n          <div className="App">\n            <p>{n}</p>\n            <button onClick={() => setN(n + 1)}>n+1</button>\n            <p>{m}</p>\n            <button onClick={() => setM(m + 1)}>m+1</button>\n          </div>\n        );\n    }\n    ReactDOM.render(<App />, rootElement);\n')])])])]),t._v(" "),n("li",[n("p",[t._v("如此就实现了两个数据的 useState，但依然存在缺点：useState 的调用顺序很关键，如果本次渲染与上次渲染调用顺序不同，可能会出现数据混乱的情况")])]),t._v(" "),n("li",[n("p",[t._v("所以，每个组件都需要有对应的_state 和 index，并且命名不能冲突。所以 React 为每个组件都创建了一个_state 和 index，并把它们放在组件对应的虚拟节点对象上。")])]),t._v(" "),n("li",[n("p",[t._v("React 节点应该是 FiberNode，_state 的名称为 memorizedState，index 的实现则是用了链表。如果你想要更深入的了解，可以阅读这篇博客：https://juejin.im/post/5bdfc1c4e51d4539f4178e1f")])])]),t._v(" "),n("h5",{attrs:{id:"react-对于函数式编程的设计思想的坚持"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#react-对于函数式编程的设计思想的坚持"}},[t._v("#")]),t._v(" React 对于函数式编程的设计思想的坚持")]),t._v(" "),n("ul",[n("li",[t._v("React 不支持对一个值进行修改，所以当你使用修改值的方法时，React 不会对 UI 进行更新")])]),t._v(" "),n("ul",[n("li",[t._v("useState 不会改变 state 中的 n，而是会生成一个新的 n")])]),t._v(" "),n("ul",[n("li",[t._v("实现'一个'n （对这个 n 进行操作即可）的方法：\n"),n("ul",[n("li",[t._v("使用 window.n 代替 n")]),t._v(" "),n("li",[t._v("可以使用 useRef 代替 useState ，来使 n 变为一个贯穿始终的 n")])]),t._v(" "),n("ul",[n("li",[t._v("useContext 不仅能贯穿始终，还能贯穿不同的组件")])])])]),t._v(" "),n("h5",{attrs:{id:"useref"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#useref"}},[t._v("#")]),t._v(" useRef")]),t._v(" "),n("ul",[n("li",[n("p",[t._v("useRef 不仅可以用于 div，还能用于任意数据")])]),t._v(" "),n("li",[n("p",[t._v("但由于 React 对于函数式编程的设计思想的坚持，React 不会在 useRef 更新后自动触发 UI 更新")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('  function App() {\n    const nRef = React.useRef(0); // {current:0}\n    const log = () => setTimeout(() => console.log(`n: ${nRef.current}`), 1000);\n    const update = React.useState(null)[1]   // 手动强制触发更新（不推荐）\n    return (\n      <div className="App">\n        <p>{nRef.current} 这里并不能实时更新</p>\n        <p>\n          <button onClick={() => {nRef.current += 1; update(nRef.current)}}>+1</button>\n          <button onClick={log}>log</button>\n        </p>\n      </div>\n    );\n  }\n')])])])])]),t._v(" "),n("h5",{attrs:{id:"usecontext"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#usecontext"}},[t._v("#")]),t._v(" useContext")]),t._v(" "),n("ul",[n("li",[n("p",[t._v("组件内任意后代组件都可以访问到数据")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('  const themeContext = React.createContext(null); // 创建context\n\n  function App() {\n    const [theme, setTheme] = React.useState("red");\n    return (\n      <themeContext.Provider value={{ theme, setTheme }}> // 容器+传递\n        <div className={`App ${theme}`}>\n          <p>{theme}</p>\n          <div>\n            <ChildA />\n          </div>\n          <div>\n            <ChildB />\n          </div>\n        </div>\n      </themeContext.Provider>\n    );\n  }\n\n  function ChildA() {\n    const { setTheme } = React.useContext(themeContext); // 接收\n    return (\n      <div>\n        <button onClick={() => setTheme("red")}>red</button>\n      </div>\n    );\n  }\n\n  function ChildB() {\n    const { setTheme } = React.useContext(themeContext);\n    return (\n      <div>\n        <button onClick={() => setTheme("blue")}>blue</button>\n      </div>\n    );\n  }\n\n  ReactDOM.render(<App />, rootElement);\n')])])])])])])}),[],!1,null,null,null);e.default=s.exports}}]);