<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>面试押题 | 一起学前端</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="">
    <meta name="description" content="">
    
    <link rel="preload" href="/assets/css/0.styles.c743a759.css" as="style"><link rel="preload" href="/assets/js/app.3aeb1e98.js" as="script"><link rel="preload" href="/assets/js/2.83af3cc0.js" as="script"><link rel="preload" href="/assets/js/16.dca47ed7.js" as="script"><link rel="prefetch" href="/assets/js/10.3b2706bb.js"><link rel="prefetch" href="/assets/js/100.c8f756f0.js"><link rel="prefetch" href="/assets/js/101.04b72338.js"><link rel="prefetch" href="/assets/js/102.8a80ca0d.js"><link rel="prefetch" href="/assets/js/103.39222573.js"><link rel="prefetch" href="/assets/js/104.ef400740.js"><link rel="prefetch" href="/assets/js/105.cec6e582.js"><link rel="prefetch" href="/assets/js/106.b3f2d115.js"><link rel="prefetch" href="/assets/js/107.6fab1075.js"><link rel="prefetch" href="/assets/js/108.34b05216.js"><link rel="prefetch" href="/assets/js/109.097f1fcb.js"><link rel="prefetch" href="/assets/js/11.d0e2210e.js"><link rel="prefetch" href="/assets/js/110.98b0cd18.js"><link rel="prefetch" href="/assets/js/111.ac942fbf.js"><link rel="prefetch" href="/assets/js/112.37924f75.js"><link rel="prefetch" href="/assets/js/113.e0f894d4.js"><link rel="prefetch" href="/assets/js/114.d2967b20.js"><link rel="prefetch" href="/assets/js/115.42ac08cd.js"><link rel="prefetch" href="/assets/js/116.d91753ef.js"><link rel="prefetch" href="/assets/js/117.f4538cd6.js"><link rel="prefetch" href="/assets/js/118.2d8297db.js"><link rel="prefetch" href="/assets/js/119.e655a176.js"><link rel="prefetch" href="/assets/js/12.f8c43eb2.js"><link rel="prefetch" href="/assets/js/120.9de91b9b.js"><link rel="prefetch" href="/assets/js/121.c87bffa0.js"><link rel="prefetch" href="/assets/js/122.3da90492.js"><link rel="prefetch" href="/assets/js/123.b0f831ca.js"><link rel="prefetch" href="/assets/js/124.55deaf22.js"><link rel="prefetch" href="/assets/js/125.ce7b3e7e.js"><link rel="prefetch" href="/assets/js/126.f1046b02.js"><link rel="prefetch" href="/assets/js/127.4f2064bd.js"><link rel="prefetch" href="/assets/js/128.954f6993.js"><link rel="prefetch" href="/assets/js/129.27175358.js"><link rel="prefetch" href="/assets/js/13.b0d38a0a.js"><link rel="prefetch" href="/assets/js/130.eeffe648.js"><link rel="prefetch" href="/assets/js/131.6fb52502.js"><link rel="prefetch" href="/assets/js/132.d69871d0.js"><link rel="prefetch" href="/assets/js/133.0d1c7395.js"><link rel="prefetch" href="/assets/js/134.20aa1a8e.js"><link rel="prefetch" href="/assets/js/135.4dceb969.js"><link rel="prefetch" href="/assets/js/136.2a931837.js"><link rel="prefetch" href="/assets/js/137.4a3ea2bc.js"><link rel="prefetch" href="/assets/js/138.f3835b29.js"><link rel="prefetch" href="/assets/js/139.b9f3bbb3.js"><link rel="prefetch" href="/assets/js/14.fe64de54.js"><link rel="prefetch" href="/assets/js/140.811b72d5.js"><link rel="prefetch" href="/assets/js/141.80a96e0b.js"><link rel="prefetch" href="/assets/js/142.9fe53172.js"><link rel="prefetch" href="/assets/js/143.f1f9891c.js"><link rel="prefetch" href="/assets/js/144.09369c3e.js"><link rel="prefetch" href="/assets/js/15.7784b150.js"><link rel="prefetch" href="/assets/js/17.053c0c85.js"><link rel="prefetch" href="/assets/js/18.7d76c9cc.js"><link rel="prefetch" href="/assets/js/19.504036bb.js"><link rel="prefetch" href="/assets/js/20.cdf651a9.js"><link rel="prefetch" href="/assets/js/21.750cb245.js"><link rel="prefetch" href="/assets/js/22.85646704.js"><link rel="prefetch" href="/assets/js/23.9c2d9bfa.js"><link rel="prefetch" href="/assets/js/24.b9b5e278.js"><link rel="prefetch" href="/assets/js/25.787db747.js"><link rel="prefetch" href="/assets/js/26.1b65e7e2.js"><link rel="prefetch" href="/assets/js/27.5b29b74d.js"><link rel="prefetch" href="/assets/js/28.c41c72df.js"><link rel="prefetch" href="/assets/js/29.f452a5af.js"><link rel="prefetch" href="/assets/js/3.b7576c58.js"><link rel="prefetch" href="/assets/js/30.4d7c359f.js"><link rel="prefetch" href="/assets/js/31.6cf93bd9.js"><link rel="prefetch" href="/assets/js/32.b3e0e356.js"><link rel="prefetch" href="/assets/js/33.731b7cbd.js"><link rel="prefetch" href="/assets/js/34.eb522b7e.js"><link rel="prefetch" href="/assets/js/35.7e9a32ef.js"><link rel="prefetch" href="/assets/js/36.7d0ff7fd.js"><link rel="prefetch" href="/assets/js/37.f6bb08ad.js"><link rel="prefetch" href="/assets/js/38.cdb5bb8c.js"><link rel="prefetch" href="/assets/js/39.f16d59e2.js"><link rel="prefetch" href="/assets/js/4.30bc6949.js"><link rel="prefetch" href="/assets/js/40.c3b52b21.js"><link rel="prefetch" href="/assets/js/41.3cf2209b.js"><link rel="prefetch" href="/assets/js/42.acafff1c.js"><link rel="prefetch" href="/assets/js/43.33fc0f17.js"><link rel="prefetch" href="/assets/js/44.4a24ebd3.js"><link rel="prefetch" href="/assets/js/45.47b9a80c.js"><link rel="prefetch" href="/assets/js/46.a20cee2e.js"><link rel="prefetch" href="/assets/js/47.ef3e96e9.js"><link rel="prefetch" href="/assets/js/48.2923f43d.js"><link rel="prefetch" href="/assets/js/49.30e0fe44.js"><link rel="prefetch" href="/assets/js/5.7c7749a8.js"><link rel="prefetch" href="/assets/js/50.2f619fa8.js"><link rel="prefetch" href="/assets/js/51.85cd9572.js"><link rel="prefetch" href="/assets/js/52.37869db5.js"><link rel="prefetch" href="/assets/js/53.c0127118.js"><link rel="prefetch" href="/assets/js/54.75416c42.js"><link rel="prefetch" href="/assets/js/55.3a777cbe.js"><link rel="prefetch" href="/assets/js/56.f6dab9be.js"><link rel="prefetch" href="/assets/js/57.63169b90.js"><link rel="prefetch" href="/assets/js/58.96fbacda.js"><link rel="prefetch" href="/assets/js/59.10f7f026.js"><link rel="prefetch" href="/assets/js/6.10d1cb7c.js"><link rel="prefetch" href="/assets/js/60.293b9f06.js"><link rel="prefetch" href="/assets/js/61.dc639372.js"><link rel="prefetch" href="/assets/js/62.1d8a67bb.js"><link rel="prefetch" href="/assets/js/63.8710c4e1.js"><link rel="prefetch" href="/assets/js/64.2730d625.js"><link rel="prefetch" href="/assets/js/65.6d547ea3.js"><link rel="prefetch" href="/assets/js/66.3f14281d.js"><link rel="prefetch" href="/assets/js/67.a224fdad.js"><link rel="prefetch" href="/assets/js/68.08d33173.js"><link rel="prefetch" href="/assets/js/69.c372c0a4.js"><link rel="prefetch" href="/assets/js/7.7aaacf14.js"><link rel="prefetch" href="/assets/js/70.ad6c1a77.js"><link rel="prefetch" href="/assets/js/71.7d6cd811.js"><link rel="prefetch" href="/assets/js/72.7f03d2ea.js"><link rel="prefetch" href="/assets/js/73.b5813982.js"><link rel="prefetch" href="/assets/js/74.81032885.js"><link rel="prefetch" href="/assets/js/75.9e69c8bb.js"><link rel="prefetch" href="/assets/js/76.404bebc2.js"><link rel="prefetch" href="/assets/js/77.88a71943.js"><link rel="prefetch" href="/assets/js/78.35991ca7.js"><link rel="prefetch" href="/assets/js/79.42544d6c.js"><link rel="prefetch" href="/assets/js/8.369c074c.js"><link rel="prefetch" href="/assets/js/80.3ea8d15e.js"><link rel="prefetch" href="/assets/js/81.ffa2550d.js"><link rel="prefetch" href="/assets/js/82.92c95751.js"><link rel="prefetch" href="/assets/js/83.db1129ed.js"><link rel="prefetch" href="/assets/js/84.0d4ed3df.js"><link rel="prefetch" href="/assets/js/85.a82eed90.js"><link rel="prefetch" href="/assets/js/86.dc7872e9.js"><link rel="prefetch" href="/assets/js/87.eadf1786.js"><link rel="prefetch" href="/assets/js/88.4a476129.js"><link rel="prefetch" href="/assets/js/89.719bfd17.js"><link rel="prefetch" href="/assets/js/9.1bc77ba7.js"><link rel="prefetch" href="/assets/js/90.4fd24039.js"><link rel="prefetch" href="/assets/js/91.1002e8e1.js"><link rel="prefetch" href="/assets/js/92.2c249787.js"><link rel="prefetch" href="/assets/js/93.8d310eb4.js"><link rel="prefetch" href="/assets/js/94.1e299b90.js"><link rel="prefetch" href="/assets/js/95.61e63fb3.js"><link rel="prefetch" href="/assets/js/96.f1c359c1.js"><link rel="prefetch" href="/assets/js/97.b85fc8ad.js"><link rel="prefetch" href="/assets/js/98.4223ffd1.js"><link rel="prefetch" href="/assets/js/99.63a5a161.js">
    <link rel="stylesheet" href="/assets/css/0.styles.c743a759.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">一起学前端</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/interview/" class="nav-link router-link-active">
  面试题
</a></div><div class="nav-item"><a href="/vue/" class="nav-link">
  vue
</a></div><div class="nav-item"><a href="/react/" class="nav-link">
  react
</a></div><div class="nav-item"><a href="/node.js/" class="nav-link">
  node.js
</a></div><div class="nav-item"><a href="https://juejin.cn/user/2137106337773645/posts" target="_blank" rel="noopener noreferrer" class="nav-link external">
  掘金主页
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/interview/" class="nav-link router-link-active">
  面试题
</a></div><div class="nav-item"><a href="/vue/" class="nav-link">
  vue
</a></div><div class="nav-item"><a href="/react/" class="nav-link">
  react
</a></div><div class="nav-item"><a href="/node.js/" class="nav-link">
  node.js
</a></div><div class="nav-item"><a href="https://juejin.cn/user/2137106337773645/posts" target="_blank" rel="noopener noreferrer" class="nav-link external">
  掘金主页
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>前端面试题</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/interview/面试/面试题（CSS）.html" class="sidebar-link">面试题（CSS）</a></li><li><a href="/interview/面试/面试题（JS）.html" class="sidebar-link">面试题（JS）</a></li><li><a href="/interview/面试/面试题（Vue）.html" class="sidebar-link">面试题（Vue）</a></li><li><a href="/interview/面试/面试题（React）.html" class="sidebar-link">面试题（React）</a></li><li><a href="/interview/面试/面试题（TS）.html" class="sidebar-link">面试题（TS）</a></li><li><a href="/interview/面试/面试题（浏览器）.html" class="sidebar-link">面试题（浏览器）</a></li><li><a href="/interview/面试/面试题（http和TCP）.html" class="sidebar-link">面试题（http和TCP）</a></li><li><a href="/interview/面试/面试题（性能优化）.html" class="sidebar-link">面试题（性能优化）</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="html"><a href="#html" class="header-anchor">#</a> HTML</h2> <ol><li><p><strong>必考：你是如何理解 HTML 语义化的？</strong></p> <ul><li><p>举例法：<br>
HTML 语义化就是使用正确的标签（总结）段落就写 p 标签，标题就写 h1 标签，文章就写 article 标签，视频就写 video 标签，等等。</p></li> <li><p>阐述法：<br>
首先讲以前的后台开发人员使用 table 布局，然后讲美工人员使用 div+css 布局，最后讲专业的前端会使用正确的标签进行页面开发。</p></li></ul></li> <li><p>meta viewport 是做什么用的，怎么写？</p> <ul><li>举例法，然后逐个解释每个单词的意思。</li> <li>initial-scale 定义设备宽度与视口大小之间的缩放比率。</li> <li>maximum-scale 定义缩放的最大值</li> <li>minimum-scale 定义缩放的最小值</li> <li>user-scalable 如果设置为 no，用户将不能放大或缩小网页。默认值为 yes。</li></ul> <div class="language- extra-class"><pre class="language-text"><code> &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1,user-scalable=no&quot; /&gt;
</code></pre></div></li> <li><p>你用过哪些 HTML 5 标签？</p> <ul><li><p>举例法<br>
平时如果只用 div 写页面你就完了，把你平时用到的 html5 标签列举出来即可，但是要注意如果这个标签的用法比较复杂，你要先看一下 MDN 的文档再说这个标签；如果你说出一个标签，却不知道它有哪些 API，那么你就会被扣分</p></li> <li><p>内容相关：header、main、footer、article</p></li> <li><p>功能相关：canvas、video、audio（处理后续问题）</p></li></ul></li> <li><p>H5 是什么？</p> <ul><li>阐述法：<br>
搜一下知乎就知道了，H5 表示移动端页面，反正不是 HTML5。</li></ul></li></ol> <h2 id="css"><a href="#css" class="header-anchor">#</a> CSS</h2> <ol><li><p><strong>必考：两种盒模型分别说一下。</strong><br>
先说两种盒模型分别怎么写，具体到代码。然后说你平时喜欢用 border box，因为更好用。（为什么更好？写起来更方便）</p></li> <li><p><strong>必考：如何垂直居中？</strong><br>
背代码 https://jscode.me/t/topic/1936</p></li> <li><p><strong>必考：flex 怎么用，常用属性有哪些？</strong><br>
看 MDN（一个元素在左，两个元素在右： margin-left:auto）</p></li> <li><p><strong>必考：BFC 是什么？</strong><br>
块级格式化上下文<br>
背 BFC 触发条件，MDN 写了。但是不用全部背下来</p> <ul><li>浮动元素（元素的 float 不是 none）</li> <li>绝对定位元素（元素的 position 为 absolute 或 fixed）</li> <li>行内块元素</li> <li>overflow 值不为 visible 的块元素
弹性元素（display 为 flex 或 inline-flex 元素的直接子元素）</li></ul></li> <li><p>CSS 选择器优先级</p> <ul><li>背人云亦云的答案（错答案、已过时）：https://www.cnblogs.com/xugang/archive/2010/09/24/1833760.html</li> <li>看面试官脸色行事</li> <li>方方给的三句话<br>
a. 越具体优先级越高<br>
b. 同样优先级写在后面的覆盖写在前面的<br>
c. !important 优先级最高，但是要少用</li></ul></li> <li><p>清除浮动说一下
把 .clearfix 添加到容器上，里面的子元素就会清除浮动</p> <div class="language- extra-class"><pre class="language-text"><code> .clearfix:after {
    content: &quot;&quot;;
    display: block; /*或者 table*/
    clear: both;
 }
 .clearfix {
    zoom: 1; /* IE 兼容*/
 }
</code></pre></div></li></ol> <h2 id="js"><a href="#js" class="header-anchor">#</a> JS</h2> <ol><li><p><strong>必考：ES 6 语法知道哪些，分别怎么用？</strong><br>
举例法<br>
let、const、箭头函数、Promise、展开操作符、默认参数、import、export，见<a href="https://fangyinghang.com/es-6-tutorials/" target="_blank" rel="noopener noreferrer">方方整理的列表<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li> <li><p>必考 Promise、Promise.all、Promise.race 分别怎么用？</p> <ul><li>Promise 用法</li></ul> <div class="language- extra-class"><pre class="language-text"><code>   function fn(){
       return new Promise((resolve, reject)=&gt;{
           成功时调用 resolve(数据)
           失败时调用 reject(错误)
       })
   }
   fn().then(success, fail).then(success2, fail2)
</code></pre></div><ul><li>Promise.all 用法</li></ul> <div class="language- extra-class"><pre class="language-text"><code>Promise.all([promise1, promise2]).then(success1, fail1)
promise1 和 promise2 都成功才会调用 success1
</code></pre></div><ul><li>Promise.race 用法</li></ul> <div class="language- extra-class"><pre class="language-text"><code>Promise.race([promise1, promise2]).then(success1, fail1)
promise1 和 promise2 只要有一个成功就会调用 success1
</code></pre></div></li> <li><p>必考：手写函数防抖和函数节流</p> <ul><li><p>节流</p> <div class="language- extra-class"><pre class="language-text"><code>  // 节流（一段时间执行一次之后，就不执行第二次）
  function throttle(fn, delay){
      let canUse = true
      return function(){
        if(canUse){
          fn.apply(this, arguments)
          canUse = false
          setTimeout(()=&gt;canUse = true, delay)
        }
      }
  }

  const throttled = throttle(()=&gt;console.log('hi'))
  throttled()
  throttled()
</code></pre></div></li> <li><p>注意，有些地方认为节流函数不是立刻执行的，而是在冷却时间末尾执行的（相当于施法有吟唱时间），那样说也是对的。</p></li> <li><p>防抖</p></li></ul> <div class="language- extra-class"><pre class="language-text"><code>  // 防抖（一段时间会等，然后带着一起做了）
  function debounce(fn, delay){
      let timerId = null
      return function(){
        const context = this
        if(timerId){window.clearTimeout(timerId)}
        timerId = setTimeout(()=&gt;{
          fn.apply(context, arguments)
          timerId = null
        },delay)
      }
  }
  const debounced = debounce(()=&gt;console.log('hi'))
  debounced()
  debounced()
</code></pre></div></li> <li><p>必考：手写 AJAX</p> <ul><li>完整版</li></ul> <div class="language- extra-class"><pre class="language-text"><code>   var request = new XMLHttpRequest()
   request.open('GET', '/a/b/c?name=ff', true);
   request.onreadystatechange = function () {
       if(request.readyState === 4 &amp;&amp; request.status === 200) {
         console.log(request.responseText);
       }
   };
   request.send();
</code></pre></div><ul><li>简化版</li></ul> <div class="language- extra-class"><pre class="language-text"><code>var request = new XMLHttpRequest()
request.open('GET', '/a/b/c?name=ff', true)
request.onload = ()=&gt; console.log(request.responseText)
request.send()
</code></pre></div></li> <li><p>必考：这段代码里的 this 是什么？</p> <div class="language- extra-class"><pre class="language-text"><code> fn()   this =&gt; window/global
 obj.fn()   this =&gt; obj
 fn.call(xx)    this =&gt; xx
 fn.apply(xx)   this =&gt; xx
 fn.bind(xx)    this =&gt; xx
 new Fn()   this =&gt; 新的对象
 fn = ()=&gt; {}   this =&gt; 外面的 this
</code></pre></div><ul><li><a href="https://zhuanlan.zhihu.com/p/23804247" target="_blank" rel="noopener noreferrer">《this 的值到底是什么？一次说清楚》<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li> <li><p>必考：闭包/立即执行函数是什么？</p> <ul><li><a href="https://zhuanlan.zhihu.com/p/22486908" target="_blank" rel="noopener noreferrer">闭包<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://zhuanlan.zhihu.com/p/22465092" target="_blank" rel="noopener noreferrer">立即执行函数<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li> <li><p>必考：什么是 JSONP，什么是 CORS，什么是跨域？</p> <ul><li><a href="https://zhuanlan.zhihu.com/p/22600501" target="_blank" rel="noopener noreferrer">JSONP<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="noopener noreferrer">CORS<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li> <li><p>常考：async/await 怎么用，如何捕获异常？<br> <a href="https://es6.ruanyifeng.com/?search=async&amp;x=0&amp;y=0#docs/async" target="_blank" rel="noopener noreferrer">阮一峰的书<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li> <li><p>常考：如何实现深拷贝？<br>
要点：</p> <ul><li>递归</li> <li>判断类型</li> <li>检查环（也叫循环引用）</li> <li>需要忽略原型</li></ul></li> <li><p>常考：如何用正则实现 trim()？</p> <div class="language- extra-class"><pre class="language-text"><code>String.prototype.trim = function(){
  return this.replace(/^\s+|\s+$/g, '')
}
</code></pre></div><p>//或者</p> <div class="language- extra-class"><pre class="language-text"><code>function trim(string){
  return string.replace(/^\s+|\s+\$/g, '')
}
</code></pre></div></li> <li><p>常考：不用 class 如何实现继承？用 class 又如何实现？</p> <ul><li><p>不用 class</p> <div class="language- extra-class"><pre class="language-text"><code>function Animal(color){
    this.color = color
}
Animal.prototype.move = function(){} // 动物可以动
function Dog(color, name){
    Animal.call(this, color) // 或者 Animal.apply(this, arguments)
    this.name = name
}
// 下面三行实现 Dog.prototype.__proto__ = Animal.prototype
function temp(){}
temp.prototye = Animal.prototype
Dog.prototype = new temp()

Dog.prototype.constructor = Dog // 这行看不懂就算了，面试官也不问
Dog.prototype.say = function(){ console.log('汪')}

var dog = new Dog('黄色','阿黄')
</code></pre></div></li></ul> <ul><li><p>class</p> <div class="language- extra-class"><pre class="language-text"><code>  class Animal{
    constructor(color){
      this.color = color
    }
    move(){}
    }
    class Dog extends Animal{
      constructor(color, name){
      super(color)
      this.name = name
    }
    say(){}
  }
</code></pre></div></li></ul></li> <li><p>常考：如何实现数组去重？</p> <ul><li>计数排序变形（hash）<div class="language- extra-class"><pre class="language-text"><code>  unique = (array) =&gt; {
    const hash = [];
    for (let i = 0; i &lt; array.length; i++) {
      hash[array[i]] = true;
    }
    const result = [];
    for (let k in hash) {
      result.push(k);
    }
    return result;
  };
</code></pre></div>缺点：只支持数字或者字符串数组，如果数组里面有对象，比如 array = [{number:1}, 2]，就会出错。</li> <li>使用 Set（面试已经禁止这种了，因为太简单）<div class="language- extra-class"><pre class="language-text"><code>  unique = (array) =&gt; {
    return [...new Set(array)];
    // 或者 return Array.from(new Set(array))
  };
</code></pre></div></li> <li>使用 WeakMap（支持所有类型去重）<div class="language- extra-class"><pre class="language-text"><code>  unique = (array) =&gt; {
    let map = new Map();
    let result = [];
    for (let i = 0; i &lt; array.length; i++) {
      if (map.has(array[i])) {
        // 判断 map 中是否已有该 key
        continue;
      } else {
        // 如果 map 中没有该 key，就加入 result 中
        map.set(array[i], true);
        result.push(array[i]);
      }
    }
    return result;
  };
</code></pre></div></li></ul></li> <li><p>放弃：== 相关题目（反着答）<br>
不要背，记不住，太复杂且没有规律</p></li> <li><p>送命题：手写一个 Promise<br>
提前写一遍，放在博客里，参考 https://juejin.im/post/5aafe3edf265da238f125c0a</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Promise</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  state <span class="token operator">=</span> <span class="token string">'pending'</span>
  succeed <span class="token operator">=</span> <span class="token keyword">null</span>
  fail <span class="token operator">=</span> <span class="token keyword">null</span>

  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token parameter">result</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token string">'fulfilled'</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">succeed</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token function">reject</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token string">'rejected'</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">fn</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">succeed<span class="token punctuation">,</span> fail</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>succeed <span class="token operator">=</span> succeed
    <span class="token keyword">this</span><span class="token punctuation">.</span>fail <span class="token operator">=</span> fail
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ol> <h2 id="dom"><a href="#dom" class="header-anchor">#</a> DOM</h2> <ol><li><p>必考：事件委托</p> <ul><li>简单版<br>
bug 在于，如果用户点击的是 li 里面的 span，就没法触发 fn，这显然不对。</li></ul> <div class="language- extra-class"><pre class="language-text"><code> ul.addEventListener('click', function(e){
       if(e.target.tagName.toLowerCase() === 'li'){
           fn() // 执行某个函数
       }
 })
</code></pre></div><ul><li>高级版<br>
思路是点击 span 后，递归遍历 span 的祖先元素看其中有没有 ul 里面的 li。</li></ul> <div class="language- extra-class"><pre class="language-text"><code> function delegate(element, eventType, selector, fn) {
       element.addEventListener(eventType, e =&gt; {
         let el = e.target
         while (!el.matches(selector)) {
           if (element === el) {
             el = null
             break
           }
           el = el.parentNode
         }
         el &amp;&amp; fn.call(el, e, el)
       })
       return element
   }
</code></pre></div></li> <li><p>曾考：用 mouse 事件写一个可拖曳的 div<br>
参考代码：https://jsbin.com/caxorunapi/edit?html,js,output</p></li></ol> <h2 id="http"><a href="#http" class="header-anchor">#</a> HTTP</h2> <ol><li><p>必考：HTTP 状态码知道哪些？分别什么意思？</p> <ul><li><p>2xx 表示成功</p></li> <li><p>3xx 表示需要进一步操作</p></li> <li><p>4xx 表示浏览器方面出错</p></li> <li><p>5xx 表示服务器方面出错</p></li> <li><p>状态码 100 表示继续，应继续其请求。</p></li> <li><p>状态码 200 表示响应成功。</p></li> <li><p>状态码 404 表示请求的资源不存在。</p></li> <li><p>状态码 201 表示请求成功， 并因此创建了新资源。 这通常是在 POST 请求或某些 PUT 请求之后发送的响应。</p></li> <li><p>状态码 301 表示请求永久重定向。</p></li> <li><p>状态码 302 表示请求临时重定向。</p></li> <li><p>状态码 304 Not Modified 文件未修改，可以直接使用缓存的文件。</p></li> <li><p>状态码 400 表示由于语法无效，服务器无法理解该请求。</p></li> <li><p>状态码 401 表示请求未经授权。 这个状态代码必须和 WWW - Authenticate 报头域一起使用。</p></li> <li><p>状态码 403 表示服务器收到请求， 但是拒绝提供服务。 服务器通常会在响应正文中给出不提供服务的原因。</p></li> <li><p>状态码 500 表示服务器发生不可预期的错误， 导致无法完成客户端的请求。</p></li> <li><p>状态码 503 表示服务器当前不能够处理客户端的请求， 在一段时间之后， 服务器可能会恢复正常。</p></li></ul> <ul><li>google 搜索 http status cat</li></ul> <ul><li>完整参考 http://www.runoob.com/http/http-status-codes.html</li></ul></li> <li><p>大公司必考：HTTP 缓存有哪几种？</p> <ul><li>需要详细的了解 ETag、CacheControl、Expires 的异同</li> <li>参考 https://imweb.io/topic/5795dcb6fb312541492eda8c</li></ul> <ul><li>答题要点：
<ul><li>ETag 是通过对比浏览器和服务器资源的特征值（如 MD5）来决定是否要发送文件内容，如果一样就只发送 304（not modified）（有请求）</li> <li>Expires 是设置过期时间（绝对时间），但是如果用户的本地时间错乱了，可能会有问题</li> <li>CacheControl: max-age=3600 是设置过期时长（相对时间），跟本地时间无关。（无请求）</li></ul></li></ul></li> <li><p>必考：GET 和 POST 的区别</p> <ul><li>简易答案
<ul><li>POST 安全，GET 不安全（都不安全）</li> <li>GET url 有长度限制，POST 没有（浏览器有长度限制）</li> <li>GET 参数放在 url 中，POST 参数放到请求体中</li> <li>GET 只需要一个报文（请求头），POST 需要两个以上（请求头和请求体）</li> <li>GET 幂等，POST 不幂等（结果是否相同）</li></ul></li></ul> <ul><li>错解，但是能过面试
<ul><li>GET 在浏览器回退时是无害的，而 POST 会再次提交请求。</li> <li>GET 产生的 URL 地址可以被加入收藏栏，而 POST 不可以。</li> <li>GET 请求会被浏览器主动 cache，而 POST 不会，除非手动设置。</li> <li>GET 请求只能进行 url 编码，而 POST 支持多种编码方式。</li> <li>GET 请求参数会被完整保留在浏览器历史记录里，而 POST 中的参数不会被保留。</li> <li>GET 请求在 URL 中传送的参数是有长度限制的，而 POST 没有。</li> <li>对参数的数据类型，GET 只接受 ASCII 字符，而 POST 没有限制。</li> <li>GET 比 POST 更不安全，因为参数直接暴露在 URL 上，所以不能用来传递敏感信息。</li> <li>GET 参数通过 URL 传递，POST 放在 Request body 中。
正解</li></ul></li> <li>就一个区别：语义——GET 用于获取资源，POST 用于提交资源。</li> <li>想装逼请参考 https://zhuanlan.zhihu.com/p/22536382</li></ul></li> <li><p>Cookie V.S. LocalStorage V.S. SessionStorage V.S. Session</p> <ul><li>Cookie V.S. LocalStorage
主要区别是 Cookie 会被发送到服务器，而 LocalStorage 不会
Cookie 一般最大 4k，LocalStorage 可以用 5Mb 甚至 10Mb（各浏览器不同）</li> <li>LocalStorage V.S. SessionStorage
LocalStorage 一般不会自动过期（除非用户手动清除），而 SessionStorage 在回话结束时过期（如关闭浏览器）</li> <li>Cookie V.S. Session
Cookie 存在浏览器的文件里，Session 存在服务器的文件里
Session 是基于 Cookie 实现的，具体做法就是把 SessionID 存在 Cookie 里</li></ul></li> <li><p>HTTP2 与 HTTP1 的区别</p> <ul><li>多路复用（MultiPlexing），即连接共享，即每一个 request 都是是用作连接共享机制的。一个 request 对应一个 id，这样一个连接上可以有多个 request，每个连接的 request 可以随机的混杂在一起，接收方可以根据 request 的 id 将 request 再归属到各自不同的服务端请求里面。</li> <li>服务端推送（server push），同 SPDY 一样，HTTP2.0 也具有 server push 功能。</li> <li>HTTP 2 默认开启 HTTPS</li></ul></li></ol> <h2 id="vue"><a href="#vue" class="header-anchor">#</a> Vue</h2> <ol><li><p>必考：watch 和 computed 和 methods 区别是什么？</p> <ul><li>思路：先翻译单词，再阐述作用，最后强行找不同。</li> <li>要点：
<ul><li>computed 和 methods 相比，最大区别是 computed 有缓存：如果 computed 属性依赖的属性没有变化，那么 computed 属性就不会重新计算。methods 则是看到一次计算一次。</li> <li>watch 和 computed 相比，computed 是计算出一个属性（废话），而 watch 则可能是做别的事情（如上报数据）</li></ul></li></ul></li> <li><p>必考：Vue 有哪些生命周期钩子函数？分别有什么用？</p> <ul><li>钩子在文档全都有，看红色的字。</li> <li>把名字翻译一遍就是满分</li> <li>要特别说明哪个钩子里请求数据，答案是 mounted</li></ul></li> <li><p>必考：Vue 如何实现组件间通信？</p> <ul><li>父子组件：使用 v-on 通过事件通信<div class="language- extra-class"><pre class="language-text"><code>$on('xxx',function(){})
$emit('xxx',data)
</code></pre></div></li> <li>爷孙组件：使用两次 v-on 通过爷爷爸爸通信，爸爸儿子通信实现爷孙通信</li> <li>任意组件：使用 eventBus = new Vue() 来通信，eventBus.$on 和 eventBus.$emit 是主要 API</li> <li>任意组件：使用 Vuex 通信</li></ul></li> <li><p>必考：Vue 数据响应式怎么做到的？</p> <ul><li>答案在文档<a href="https://cn.vuejs.org/v2/guide/reactivity.html" target="_blank" rel="noopener noreferrer">《深入响应式原理》<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>要点
<ul><li>使用 Object.defineProperty 把这些属性全部转为 getter/setter</li> <li>Vue 不能检测到对象属性的添加或删除，解决方法是手动调用 Vue.set 或者 this.<code>$</code>set</li></ul></li></ul></li> <li><p>必考：Vue.set 是做什么用的？
见上一题</p></li> <li><p>Vuex 你怎么用的？</p> <ul><li><p>背下文档第一句：Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式</p></li> <li><p>说出核心概念的名字和作用：State/Getter/Mutation/Action/Module</p></li> <li><p>State 唯一数据源</p></li> <li><p>Getter state 的计算属性</p> <div class="language- extra-class"><pre class="language-text"><code>   const store = new Vuex.Store({
     state: {
       todos: [
         { id: 1, text: '...', done: true },
         { id: 2, text: '...', done: false }
       ]
     },
     getters: {
       doneTodos: state =&gt; {
         return state.todos.filter(todo =&gt; todo.done)
       }
     }
   })
   store.getters.doneTodos
</code></pre></div></li> <li><p>Mutation 修改状态（同步）</p> <div class="language- extra-class"><pre class="language-text"><code> const store = new Vuex.Store({
     state: {
       count: 1
     },
     mutations: {
       increment (state) {
         // 变更状态
         state.count++
       }
     }
   })
   store.commit('increment')
</code></pre></div></li> <li><p>Action 提交 mutation（异步）</p> <div class="language- extra-class"><pre class="language-text"><code> actions: {
     incrementAsync ({ commit }) {
       setTimeout(() =&gt; {
         commit('increment')
       }, 1000)
     }
 }
 store.dispatch('increment')
</code></pre></div></li> <li><p>Module 分割为模块</p> <div class="language- extra-class"><pre class="language-text"><code> const moduleA = {
     state: { ... },
     mutations: { ... },
     actions: { ... },
     getters: { ... }
 }
 const moduleB = {
     state: { ... },
     mutations: { ... },
     actions: { ... }
 }
 const store = new Vuex.Store({
     modules: {
       a: moduleA,
       b: moduleB
     }
 })
 store.state.a // -&gt; moduleA 的状态
 store.state.b // -&gt; moduleB 的状态
</code></pre></div></li></ul></li> <li><p>VueRouter 你怎么用的？</p> <ul><li>Vue Router 是 Vue.js 官方的路由管理器。</li> <li>History 模式/导航守卫/路由懒加载</li> <li>常用 API：router-link、router-view、this.$router.push、this.$router.replace、this.<code>$</code>route.params</li></ul> <div class="language- extra-class"><pre class="language-text"><code>this.$router.push('/user-admin') // 向 history 栈添加一个新的记录，当用户点击浏览器后退按钮时，则回到之前的 URL。
this.$router.replace('/user-admin') // 不会向 history 添加新记录，而是替换掉当前的 history 记录。
this.$route.params // 包含了动态片段和全匹配片段的对象，如果没有路由参数，就是一个空对象。
</code></pre></div></li> <li><p>路由守卫是什么？
“导航”表示路由正在发生改变。导航守卫主要用来通过跳转或取消的方式守卫导航</p> <ul><li>全局前置守卫（router.beforeEach） 登录验证</li> <li>全局解析守卫（router.beforeResolve） 在导航被确认之前，在所有组件内守卫和异步路由组件被解析之后</li> <li>全局后置钩子（router.afterEach） 路由跳转完成后触发</li> <li>路由独享的守卫（beforeEnter） beforeEnter 在 beforeEach 之后紧随执行</li> <li>组件内的守卫<div class="language- extra-class"><pre class="language-text"><code>beforeRouteEnter  // 在全局守卫beforeEach和独享守卫beforeEnter之后，全局beforeResolve和全局afterEach之前调用
beforeRouteUpdate  // 当前路由改变，并且该组件被复用时调用
beforeRouteLeave  // 导航离开该组件的对应路由时调用
</code></pre></div></li></ul> <ul><li>https://juejin.im/post/5d639ecb5188255d7d6517fb</li></ul></li></ol> <h2 id="react"><a href="#react" class="header-anchor">#</a> React</h2> <ol><li><p>必考：受控组件 V.S. 非受控组件</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;FInput value={x} onChange={fn}/&gt; 受控组件
&lt;FInput defaultValue={x} ref={input}/&gt; 非受控组件
</code></pre></div><p>区别：受控组件的状态由开发者维护，非受控组件的状态由组件自身维护（不受开发者控制）</p></li> <li><p>必考：React 有哪些生命周期函数？分别有什么用？（Ajax 请求放在哪个阶段？）</p> <ul><li>constructor() 初始化 state 和 props</li> <li>render() 渲染（必须执行）</li> <li>componentDidMount() 请求数据</li> <li>componentDidUpdate() 视图更新后执行</li> <li>componentWillUnmount() 组件被移除页面并销毁</li> <li>shouldComponentUpdate() 组件是否更新 UI</li></ul></li> <li><p>必考：React 如何实现组件间通信？</p> <ul><li>父子靠 props 传函数</li> <li>爷孙可以穿两次 props</li> <li>任意组件用 Redux（也可以自己写一个 eventBus）</li></ul></li> <li><p>必考：shouldComponentUpdate 有什么用？</p> <ul><li>要点：用于在没有必要更新 UI 的时候返回 false，以提高渲染性能</li> <li>参考：http://taobaofed.org/blog/2016/08/12/optimized-react-components/</li></ul></li> <li><p>必考：虚拟 DOM 是什么？</p> <ul><li>要点：虚拟 DOM 就是用来模拟 DOM 的一个对象，这个对象拥有一些重要属性，并且更新 UI 主要就是通过对比（DIFF）旧的虚拟 DOM 树和新的虚拟 DOM 树的区别完成的。</li> <li>参考：http://www.alloyteam.com/2015/10/react-virtual-analysis-of-the-dom/</li></ul></li> <li><p>必考：什么是高阶组件？</p> <ul><li>要点：文档原话——高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件。</li> <li>举例：React-Redux 里 connect 就是一个高阶组件，比如 connect(mapState)(MyComponent) 接受组件 MyComponent，返回一个具有状态的新 MyComponent 组件。</li></ul></li> <li><p>React diff 的原理是什么？
看你记忆力了：https://imweb.io/topic/579e33d693d9938132cc8d94</p></li> <li><p>必考 Redux 是什么？</p> <ul><li>Redux 是 JavaScript 状态容器，提供可预测化的状态管理。重点是『状态管理』。</li> <li>Action/Reducer/Store/单向数据流<div class="language- extra-class"><pre class="language-text"><code>Store  唯一数据源
Action  描述一个事件以及必要参数（对象）
Reducer  根据Action对数据进行操作（函数）
</code></pre></div></li> <li>常用 API：store.dispatch(action)/store.getState()<div class="language- extra-class"><pre class="language-text"><code>const store = createStore(todos, ['Use Redux'])
store.dispatch({
  type: 'ADD_TODO',
  text: 'Read the docs'
})
store.subscribe(() =&gt; {
  this.setState({
    items: store.getState().items;
  });
});
</code></pre></div></li></ul></li> <li><p>connect 的原理是什么？</p> <ul><li>react-redux 库提供的一个 API，connect 的作用是让你把组件和 store 连接起来，产生一个新的组件（connect 是高阶组件）<div class="language- extra-class"><pre class="language-text"><code>export default connect(
  mapStateToProps,
  mapDispatchToProps
)(Counter);
</code></pre></div></li> <li>参考：https://segmentfault.com/a/1190000017064759</li></ul></li></ol> <h2 id="typescript"><a href="#typescript" class="header-anchor">#</a> TypeScript</h2> <ol><li>never 类型是什么？
不应该出现的类型</li> <li>TypeScript 比起 JavaScript 有什么优点？
提供了类型约束，因此更可控、更容易重构、更适合大型项目、更容易维护</li></ol> <h2 id="webpack"><a href="#webpack" class="header-anchor">#</a> Webpack</h2> <ol><li><p>必考：有哪些常见 loader 和 plugin，你用过哪些？</p> <ul><li>loader
<ul><li>html: pug-loader markdown-loader</li> <li>CSS: postcss-loader scss-loader less-loader style-loader</li> <li>js: babel-loader</li></ul></li> <li>plugin
<ul><li>html: html-webpack-plugin</li> <li>css: extract-text-plugin</li></ul></li></ul></li> <li><p>英语题：loader 和 plugin 的区别是什么？</p></li> <li><p>必考：如何按需加载代码？
import('文件路径').then()</p></li> <li><p>必考：如何提高构建速度？</p> <ul><li>code split</li> <li>多入口情况下，使用 CommonsChunkPlugin 来提取公共代码</li> <li>通过 externals 配置来提取常用库</li> <li>利用 DllPlugin 和 DllReferencePlugin 预编译资源模块 通过 DllPlugin 来对那些我们引用但是绝对不会修改的 npm 包来进行预编译，再通过 DllReferencePlugin 将预编译的模块加载进来。</li> <li>使用 Happypack 实现多线程加速编译</li> <li>使用 webpack-uglify-parallel 来提升 uglifyPlugin 的压缩速度。 原理上 webpack-uglify-parallel 采用了多核并行压缩来提升压缩速度</li> <li>使用 Tree-shaking 和 Scope Hoisting 来剔除多余代码</li></ul></li> <li><p>转义出的文件过大怎么办？</p> <ul><li>提取公共的模块文件</li> <li>压缩 js，css，图片</li> <li>动态加载，按需加载（import()）</li> <li>压缩代码。删除多余的代码、注释、简化代码的写法等等方式。可以利用 webpack 的 UglifyJsPlugin 和 ParallelUglifyPlugin 来压缩 JS 文件， 利用 cssnano（css-loader?minimize）来压缩 css</li> <li>利用 CDN 加速。在构建过程中，将引用的静态资源路径修改为 CDN 上对应的路径。可以利用 webpack 对于 output 参数和各 loader 的 publicPath 参数来修改资源路径</li> <li>删除死代码（Tree Shaking）。将代码中永远不会走到的片段删除掉。可以通过在启动 webpack 时追加参数--optimize-minimize 来实现
上面五题请看这个不错的参考：https://zhuanlan.zhihu.com/p/44438844</li></ul></li></ol> <h2 id="安全"><a href="#安全" class="header-anchor">#</a> 安全</h2> <ol><li><p>必考：什么是 XSS？如何预防？
比较复杂，看我的文章 https://zhuanlan.zhihu.com/p/22500730</p></li> <li><p>必考：什么是 CSRF？如何预防？
比较复杂，看若愚的文章 https://zhuanlan.zhihu.com/p/22521378</p> <p>XSS 和 CSRF：https://ju7ejin.im/entry/5b4b56fd5188251b1a7b2ac1</p></li></ol> <h2 id="开放题目"><a href="#开放题目" class="header-anchor">#</a> 开放题目</h2> <ol><li><p>必考：你遇到最难的问题是怎样的？
要点：一波三折。参考 https://www.zhihu.com/question/35323603</p></li> <li><p>你在团队的突出贡献是什么？
把小事说大。带团队学习，定期分享</p></li> <li><p>最近在关注什么新技术
书、博客、推特、知乎，不要说 CSDN、百度。</p></li> <li><p>有没有看什么源码，看了后有什么记忆深刻的地方，有什么收获</p> <ul><li>看过源码说源码，推荐看 underscore.js 的源码</li> <li>没看过源码就说同事的代码，代码烂就说哪里烂，代码好就说哪里好</li> <li>收获：命名规范、设计模式</li></ul></li></ol> <h2 id="刁钻题目"><a href="#刁钻题目" class="header-anchor">#</a> 刁钻题目</h2> <ol><li>代码
<code>[1,2,3].map(parseInt)</code>
答案:
1 NaN NaN</li> <li>代码
<code>var a = {name: 'a'} a.x = a = {}</code>
问 a.x 是多少？
答案: undefined（a 已经改变了，拿不到最初的 a）</li> <li>(a ==1 &amp;&amp; a== 2 &amp;&amp; a==3) 可能为 true 吗？</li></ol> <ul><li>利用 == 会调用 valueOf() 的特性</li></ul> <div class="language- extra-class"><pre class="language-text"><code>
        var a = {
          value: 1,
          valueOf() {
            return this.value++;
          },
        };
        a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3; // true

</code></pre></div><ul><li><p>利用 a 会读取 window.a 的特性</p> <div class="language- extra-class"><pre class="language-text"><code>    var value = 1;
    Object.defineProperty(window, &quot;a&quot;, {
      get() {
        return value++;
      },
    });
    a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3; // true
    // 或者
    a === 1 &amp;&amp; a === 2 &amp;&amp; a === 3; // true
</code></pre></div></li></ul> <h2 id="超纲题"><a href="#超纲题" class="header-anchor">#</a> 超纲题</h2> <ol><li>JS 垃圾回收机制</li></ol> <ul><li>看图讲解 https://javascript.info/garbage-collection
<ul><li>什么是垃圾
所有全局变量都不是垃圾
没有被引用通常都是垃圾（环引用依然是垃圾）</li> <li>如何捡垃圾（遍历和计数，只是不同的算法而已）
标记清除算法</li> <li>前端又有其特殊性（JS 进程和 DOM 进程）
更深入一些的讲解 http://newhtml.net/v8-garbage-collection/</li></ul></li></ul> <ol start="2"><li><p>Eventloop 说一下</p> <div class="language- extra-class"><pre class="language-text"><code>    setTimeout(function () {
      console.log(4);
    }, 0);
    new Promise(function (resolve) {
      console.log(1);
      resolve();
      console.log(2);
    }).then(function () {
      console.log(5);
    });

    console.log(3);

1;
2;
3;
5;
4;

</code></pre></div></li></ol> <ul><li>肤浅理解：『一会儿』和『尽快』异步任务</li> <li>详细理解：Eventloop 是个啥？</li> <li>浏览器有 Eventloop 吗？</li> <li>每个 API 对应哪个任务队列？
<ul><li>setTimeout</li> <li>setImmediate（浏览器没有）</li> <li>process.nextTick（浏览器没有）</li> <li>MutationObserver（Node 没有）</li> <li>promise.then</li> <li>await</li></ul></li> <li>这种题目尽量说思路，因为你不可能通过眼睛看出结果（必须画图）</li></ul> <div class="language- extra-class"><pre class="language-text"><code>
        async function async1() {
          console.log(1);
          await async2();
          console.log(2);
        }
        async function async2() {
          console.log(3);
        }

        async1();

        new Promise(function (resolve) {
          console.log(4);
          resolve();
        }).then(function () {
          console.log(5);
        });

1;
3;
4;
2;
5;

</code></pre></div><p>注意：这一题的答案不唯一，在 Node.js 和 Chrome 的结果不一样，甚至在 Chrome 上也是时而这个答案，时而那个答案。所以还是说思路最重要。</p> <h2 id="个性化题目"><a href="#个性化题目" class="header-anchor">#</a> 个性化题目</h2> <ul><li>PWA</li> <li>echarts.js / d3.js</li> <li>three.js</li> <li>flutter</li> <li>SSR
做个 hello world 基本就能应付面试了，如果怕应付不了，就再做个复杂点的。</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.3aeb1e98.js" defer></script><script src="/assets/js/2.83af3cc0.js" defer></script><script src="/assets/js/16.dca47ed7.js" defer></script>
  </body>
</html>
